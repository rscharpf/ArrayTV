%\VignetteIndexEntry{ArrayTV Vignette}
%\VignetteKeywords{copy number}
%\VignettePackage{ArrayTV}
\documentclass{article}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[numbers]{natbib}
\usepackage{color}
\usepackage[margin=1in]{geometry}

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{\texttt{#1}}
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rclass}[1]{\texttt{#1}}
\newcommand{\R}{\textsf{R}}

\title{Wave correction for arrays}
\author{Eitan Halper-Stromberg}

\begin{document}

  \maketitle

<<setup, echo=FALSE>>=
    options(width=70)
topdf <- function(){
    Sweave("ArrayTV.Rnw")
    tools::texi2pdf("ArrayTV.tex")
}
@

\begin{abstract}
  ArrayTV is a GC correction algorithm for microarray data designed to mitigate the appearance of waves.  This work is inspired by a method for mitigating waves in sequencing data (Benjamini and Speed, 2012). We find the best window, i.e the window size that most captures the dependence of signal intensity on gc content for each array using the total variance distance statistic (TV score). The correction each probe receives is the mean signal intensity of all probes sharing the same local gc. We center windows at the starting position of each probe.
\end{abstract}

\section{Calculate and Plot TV Scores}

\subsection*{generate TV scores}
<<tvscores>>=
    ## We will generate total variance scores (TV scores) for 30 window sizes to determine the
    ## optimal window(s) for our gc correction. NOTE: We use the start location of each probe as
    ## our probe locations. If you use this package with microarray data where probe locations
    ## are reported in the middle of the probes, you should adjust these so that they represent
    ## the start positions (i.e middle probe locs - probelength/2)
library(ArrayTV)
path <- system.file("extdata", package="ArrayTV")
load(file.path(path, "arrayExamples.rda"))

samplechr=c('chr15')
increms=c(10,1000,100e3)
wins=c(100,10e3,1e6)
nodes=1
library(doMC)
registerDoMC(nodes)
nimtvScores=gcCorrect(matrix(nimMs),nimchr,nimstarts,samplechr,nodes,increms,wins,
jittercorrection=FALSE,returnOnlyTV=TRUE,build='hg18')

agtvScores=gcCorrect(matrix(agMs),agchr,agstarts,samplechr,nodes,increms,wins,
jittercorrection=FALSE,returnOnlyTV=TRUE,build='hg18')

aftvScores=gcCorrect(matrix(afMs),afchr,afstarts,samplechr,nodes,increms,wins,
jittercorrection=FALSE,returnOnlyTV=TRUE,build='hg18')

tvScoresSplit=split(data.frame(nimtvScores,agtvScores,aftvScores),rep(1:3,each=10))
windowsize=c('small windows','medium windows','large windows')

@
\subsection*{view TV scores}
<<tvscorefig,fig=TRUE>>=
par(mfrow=c(1,3),mar=c(2.5,2.5,1.6,1.1),mgp=c(1.5,.5,0),oma=c(0,0,4,0))
for(ii in 1:3){
    plot(rownames(tvScoresSplit[[ii]]),tvScoresSplit[[ii]][,1],col='blue',
         ylim=c(0,max(unlist(tvScoresSplit))),
         xlab='window extension from center',
         ylab='tv score',main=windowsize[ii])
    points(rownames(tvScoresSplit[[ii]]),tvScoresSplit[[ii]][,2],col='red')
    points(rownames(tvScoresSplit[[ii]]),tvScoresSplit[[ii]][,3],col='green')
    legend('bottomright',legend=c('NimbleGen','Agilent','Affy'),col=c('red','green','blue'),pch=1)
}
@
\section{Do Correction}
\subsection*{use optimal window sizes to perform correction}
<<correct>>=
    ## We will do correction using two windows for each platform. The window sizes are chosen
    ## baed upon the tv scores generated in the last section (we choose windows with relatively
    ## large tv scores-the theory being that windows with larger tv scores are better for
    ## correction).

nimcM1=gcCorrect(matrix(nimMs),nimchr,nimstarts,samplechr,nodes,increms=6e5,maxwins=6e5,build='hg18')

nimcM2=gcCorrect(nimcM1,nimchr,nimstarts,samplechr,nodes,increms=9e3,maxwins=9e3,build='hg18')

agcM1=gcCorrect(matrix(agMs),agchr,agstarts,samplechr,nodes,increms=7e5,maxwins=7e5,build='hg18')

agcM2=gcCorrect(agcM1,agchr,agstarts,samplechr,nodes,increms=4e3,maxwins=4e3,build='hg18')

afcM1=gcCorrect(matrix(afMs),afchr,afstarts,samplechr,nodes,increms=1e3,maxwins=1e3,build='hg18')

afcM2=gcCorrect(afcM1,afchr,afstarts,samplechr,nodes,increms=3e5,maxwins=3e5,build='hg18')

wave.df <- data.frame(position=c(rep(nimstarts/1e6, 2),rep(agstarts/1e6, 2),rep(afstarts/1e6,2)),
		      r=c(nimMs, nimcM2,agMs,agcM2,afMs,afcM2),
		      wave.corr=c(rep("raw NimbleGen", nrow(nimcM2)),
                      rep("ArrayTV NimbleGen", nrow(nimcM2)),
                      rep('raw Agilent',nrow(agcM2)),rep('ArrayTV Agilent',nrow(agcM2)),
                      rep('raw Affy',nrow(afcM2)),rep('ArrayTV Affy',nrow(afcM2))))

wave.df$wave.corr <- factor(wave.df$wave.corr, levels=c("raw NimbleGen", "ArrayTV NimbleGen",
                                               "raw Agilent","ArrayTV Agilent","raw Affy",
                                               "ArrayTV Affy"))
@
\subsection*{view corrected and uncorrected signal}
<<makewavefig,fig=TRUE>>=
    ## For each of the 3 example platforms, the uncorrected signal appears immediately above the
    ## corrected signal, across chromosome 15. A smoothed loess line is drawn through each.
    library(lattice)
    p <- xyplot(r~position|wave.corr, wave.df, pch=".", col="gray",
                ylim=c(-.6,.6), xlim=c(18,102),ylab="log R ratio", xlab="position (Mb) on chr15",
                scales=list(y=list(tick.number=8)),
                panel=function(x,y,subscripts,...){
                    panel.grid(lty=2)
                    panel.xyplot(x, y, ...)
                    panel.abline(h=0)
                    panel.loess(x, y, span=1/20, lwd=2, col="black")
                }, par.strip.text=list(cex=0.9), layout=c(1,6), as.table=TRUE)

print(p)
@

\section{view a SpikeIn}
<<cbs>>=
    ## use CBS to segment corrected and uncorrected signal within a region containing a
    ## known copy number amplification (expected copy number 2.5).
    cbs.out=data.frame()
for(ii in 1:6){
    MsUse=get(c('nimMs','nimcM2','agMs','agcM2','afMs','afcM2')[ii])
    chrUse=get(c('nimchr','nimchr','agchr','agchr','afchr','afchr')[ii])
    startsUse=get(c('nimstarts','nimstarts','agstarts','agstarts','afstarts','afstarts')[ii])
    toUse=!(duplicated(startsUse))
    cna1=CNA(MsUse[toUse],chrUse[toUse],startsUse[toUse],data.type="logratio",
    unique(wave.df$wave.corr)[ii])
    segment.smoothed.CNA.object=segment(cna1,verbose=1)
    cbs.out=rbind(cbs.out,segment.smoothed.CNA.object$output)
}

cbs.out$ID=gsub('\\.',' ',cbs.out$ID)
cbs.segs <- RangedData(IRanges(cbs.out$loc.start, cbs.out$loc.end),
                       numMarkers = cbs.out$num.mark, seg.mean = cbs.out$seg.mean,
                       chrom = 14L,space=cbs.out$ID)

raw.data <- RangedData(IRanges(wave.df$position*1e6, width=1),
                       numMarkers=1,seg.mean = wave.df$r, chrom = 14L,space=wave.df$wave.corr)
spikeIn=IRanges(start=45396506,end=45537976)
spikeinStart=45396506;spikeinEnd=45537976
raw.data$cbs.seg=cbs.segs$seg.mean[findOverlaps(ranges(raw.data), ranges(cbs.segs),
select="first", drop=TRUE)]
raw.data$spikeIn=raw.data$cbs.seg
raw.data$spikeIn[which(is.na(findOverlaps(unlist(ranges(raw.data)),spikeIn,select="first")))]=NA
rawd=as.data.frame(raw.data)

## view CBS lines through the spike in (expected copy number 2.5). Black points represent
## signal intensities for each probe. Red lines represent segmentation of the
## intensities (using the circular binary segmentaion algorithm) and blue lines
## represent a region of known copy number 2.5 (a subtle amplification). As in
## the previous figure, raw signal intensities appear immediately above the corrected
## intensities for each platform

p2 <- xyplot(seg.mean+cbs.seg+spikeIn~start|space,rawd,
             ylim=c(-.6,.6),xlim=c(spikeinStart-2.4e6,spikeinEnd+2.4e6),ylab="log R ratio",
             xlab="position (in basepairs)",pch=c(".", NA,NA),
             col=c('black','red','blue'),
             distribute.type=TRUE,
             type=c('p','l','l'),lwd=c(NA,1,3),
             scales=list(y=list(tick.number=8)),
             par.strip.text=list(cex=0.9), layout=c(1,6), as.table=TRUE)
@

<<cbsfig,fig=TRUE>>=
    print(p2)
@

<<sessionInfo,echo=FALSE,results=tex>>=
    toLatex(sessionInfo())
@


\end{document}
